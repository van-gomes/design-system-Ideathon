import { g as getBrowserState, a as getWorkerState } from './index-DrTP5i7N.js';

const provider = getBrowserState().provider;
// @__NO_SIDE_EFFECTS__
function convertElementToCssSelector(element) {
  if (!element || !(element instanceof Element)) {
    throw new Error(
      `Expected DOM element to be an instance of Element, received ${typeof element}`
    );
  }
  return getUniqueCssSelector(element);
}
function escapeIdForCSSSelector(id) {
  return id.split("").map((char) => {
    const code = char.charCodeAt(0);
    if (char === " " || char === "#" || char === "." || char === ":" || char === "[" || char === "]" || char === ">" || char === "+" || char === "~" || char === "\\") {
      return `\\${char}`;
    } else if (code >= 65536) {
      return `\\${code.toString(16).toUpperCase().padStart(6, "0")} `;
    } else if (code < 32 || code === 127) {
      return `\\${code.toString(16).toUpperCase().padStart(2, "0")} `;
    } else if (code >= 128) {
      return `\\${code.toString(16).toUpperCase().padStart(2, "0")} `;
    } else {
      return char;
    }
  }).join("");
}
function getUniqueCssSelector(el) {
  const path = [];
  let parent;
  let hasShadowRoot = false;
  while (parent = getParent(el)) {
    if (parent.shadowRoot) {
      hasShadowRoot = true;
    }
    const tag = el.tagName;
    if (el.id) {
      path.push(`#${escapeIdForCSSSelector(el.id)}`);
    } else if (!el.nextElementSibling && !el.previousElementSibling) {
      path.push(tag.toLowerCase());
    } else {
      let index = 0;
      let sameTagSiblings = 0;
      let elementIndex = 0;
      for (const sibling of parent.children) {
        index++;
        if (sibling.tagName === tag) {
          sameTagSiblings++;
        }
        if (sibling === el) {
          elementIndex = index;
        }
      }
      if (sameTagSiblings > 1) {
        path.push(`${tag.toLowerCase()}:nth-child(${elementIndex})`);
      } else {
        path.push(tag.toLowerCase());
      }
    }
    el = parent;
  }
  return `${getBrowserState().provider === "webdriverio" && hasShadowRoot ? ">>>" : ""}${path.reverse().join(" > ")}`;
}
function getParent(el) {
  const parent = el.parentNode;
  if (parent instanceof ShadowRoot) {
    return parent.host;
  }
  return parent;
}
const now = Date.now;
function processTimeoutOptions(options_) {
  if (
    // if timeout is set, keep it
    options_ && options_.timeout != null || provider !== "playwright"
  ) {
    return options_;
  }
  if (getWorkerState().config.browser.providerOptions.actionTimeout != null) {
    return options_;
  }
  const currentTest = getWorkerState().current;
  const startTime = currentTest?.result?.startTime;
  if (!currentTest || currentTest.type === "suite" || !startTime) {
    return options_;
  }
  const timeout = currentTest.timeout;
  if (timeout === 0 || timeout === Number.POSITIVE_INFINITY) {
    return options_;
  }
  options_ = options_ || {};
  const currentTime = now();
  const endTime = startTime + timeout;
  const remainingTime = endTime - currentTime;
  if (remainingTime <= 0) {
    return options_;
  }
  options_.timeout = remainingTime - 100;
  return options_;
}
function getIframeScale() {
  const testerUi = window.parent.document.querySelector("#tester-ui");
  if (!testerUi) {
    throw new Error(`Cannot find Tester element. This is a bug in Vitest. Please, open a new issue with reproduction.`);
  }
  const scaleAttribute = testerUi.getAttribute("data-scale");
  const scale = Number(scaleAttribute);
  if (Number.isNaN(scale)) {
    throw new TypeError(`Cannot parse scale value from Tester element (${scaleAttribute}). This is a bug in Vitest. Please, open a new issue with reproduction.`);
  }
  return scale;
}

export { convertElementToCssSelector as c, getIframeScale as g, processTimeoutOptions as p };
